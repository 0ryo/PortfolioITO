# Project Photon: 想定質問＆回答集

現役のアプリ開発者が、学生であるあなたに対してポートフォリオとして提出された「Project Photon」について質問することを想定し、その問答集を作成しました。
質問は学生が回答に詰まりやすいであろう難易度別に分けられています。面接や技術的な会話の場で、自身の言葉で説明できるよう準備しておきましょう。

---

## 難易度：初級 (基本的な理解度を問う質問)

このレベルの質問には、アプリの概要や目的、使用した主要技術について自分の言葉で明確に説明できることが求められます。

**Q1. この「Photon」は、どのようなアプリですか？ 作ろうと思ったきっかけも教えてください。**

**A1.**
はい。「Photon」は、Webブラウザ上で動作する軽量な3Dエディタです。ユーザーは3Dモデルファイル（glTF, GLB, OBJなど）をブラウザにドラッグ＆ドロップするだけで、モデルをビューポートに表示し、移動、回転、拡大縮小といった基本的な操作ができます。
開発のきっかけは、3Dグラフィックス技術に興味があり、特にWeb上で手軽に3Dデータを扱えるツールを作りたいと考えたからです。Babylon.jsという強力なWeb 3Dエンジンを学びながら、実践的なアプリケーションとして3Dエディタの開発に挑戦しました。

**Q2. このアプリの主なターゲットユーザーは誰ですか？**

**A2.**
主なターゲットは、3Dモデルを手軽に確認したいデザイナーや開発者、または3Dプリンティング用のモデルを準備するホビイストなどを想定しています。高機能なデスクトップアプリを立ち上げるまでもなく、ブラウザで素早くモデルの内容を確認したり、簡単な調整を行ったりするユースケースを考えています。

**Q3. アプリの主な機能を3つ教えてください。**

**A3.**
はい、主な機能は3つあります。
1.  **3Dモデルのインポート機能**: ローカルにあるglTF, GLB, OBJ, STLといった複数の形式の3Dモデルファイルを読み込んで、シーンに表示する機能です。
2.  **ギズモによるオブジェクト操作**: 表示したモデルに対して、位置・回転・スケールを直感的に操作できるギズモ機能を提供しています。
3.  **インスペクター機能**: シーンに存在するメッシュやノードを階層的にリスト表示し、どのオブジェクトがシーンに存在するかを確認できます。

**Q4. なぜ3D描画ライブラリとしてBabylon.jsを選んだのですか？**

**A4.**
Three.jsも有名で検討しましたが、Babylon.jsはTypeScriptとの親和性が非常に高く、公式の型定義が充実している点に魅力を感じました。また、シーンの管理や物理エンジン、GUIといった機能がオールインワンで提供されており、多機能なエディタを開発する上で公式のサポートが手厚いと考え、採用を決めました。

**Q5. 開発で使った技術スタックを教えてください。**

**A5.**
フロントエンドのフレームワークとしてNext.jsとReactを、言語はTypeScriptを使用しています。3D描画エンジンはBabylon.js、UIコンポーネントライブラリにはChakra UIを採用しました。また、コンポーネント間で状態を共有するためにRecoilを状態管理ライブラリとして利用しています。

---

## 難易度：中級 (技術的な選択理由や実装の詳細を問う質問)

このレベルでは、「なぜその技術を選んだのか」「どのように実装したのか」という、設計や実装の意図を論理的に説明する能力が試されます。

**Q6. 3Dエディタのようなクライアントサイドで完結するアプリに、Next.jsを採用した理由は何ですか？Create React Appなどとの違いをどう考えましたか？**

**A6.**
確かにエディタのコア機能はクライアントサイドで動作しますが、Next.jsを採用したのには2つの理由があります。
1.  **APIルートの活用**: `src/pages/api/uploads`にあるように、Next.jsのAPIルート機能を使えば、ファイルアップロードのための中継サーバーなどを別途用意することなく、簡単に実装できると考えました。現在はローカルでのファイル読み込みがメインですが、将来的にクラウドストレージへモデルを保存するような機能を拡張する際に有利だと判断しました。
2.  **拡張性**: 今後、ユーザー登録機能やプロジェクト管理ページなど、サーバーサイドレンダリングが有効なページを追加する可能性を考慮しました。Create React Appでも実現可能ですが、Next.jsはそうしたハイブリッドな構成への拡張がよりスムーズに行える点が魅力でした。

**Q7. ReactのUIとBabylon.jsのシーンの間で、どのように状態を同期させていますか？例えば、モデルをインポートした際に、左側のインスペクターが更新される仕組みを教えてください。**

**A7.**
はい、ReactとBabylon.jsは宣言的なUIと命令的な操作という違いがあるため、状態同期には工夫が必要でした。このプロジェクトでは、状態管理ライブラリの**Recoil**をハブとして利用しています。
具体的な流れとして、
1.  Babylon.jsのシーン内で新しいメッシュが追加されると、`scene.onNewMeshAddedObservable`というBabylon.jsのイベント（Observable）が発火します。
2.  このイベントを購読しておき、発火したタイミングでシーン全体の階層情報を`getMeshData`という関数で解析します。
3.  解析して得られた`SceneMeshData`オブジェクトを、`useRecoilState`から取得した`setMeshList`関数を使ってRecoilのatom（`meshListState`）に保存します。
4.  左側の`Inspector`コンポーネントは、この`meshListState`を購読しています。atomの値が更新されると、Reactが差分を検知してUIを自動的に再描画するため、インスペクターのリストが更新される、という仕組みです。
このように、Babylon.jsのイベントをトリガーにRecoilのstateを更新することで、命令的な3Dシーンの変更を宣言的なReactのUIに反映させています。

**Q8. ファイルをインポートする際のロジックについて、`useAssetLoad.ts`フックの役割を教えてください。**

**A8.**
`useAssetLoad`は、3Dアセットの読み込みに関するロジックをカプセル化したカスタムフックです。このフックは、ファイル選択のinput要素の`onChange`イベントを処理する`handleSingle3dFileInput`関数を返します。
この関数内では、
1.  選択されたファイルが対応形式（glb, gltf, obj, stl）かチェックします。
2.  `URL.createObjectURL`でファイルへのローカルURLを生成します。
3.  生成したURLとファイルの拡張子をReactのstate（`assetUrl`, `assetType`）にセットします。
`BabylonEditor.tsx`コンポーネント側では、この`assetUrl`の変更を`useEffect`で監視しており、URLがセットされたら`SceneLoader.AppendAsync`を呼び出して、実際のモデル読み込み処理を開始します。このように、ファイルイベントのハンドリングと状態管理をカスタムフックに分離することで、メインコンポーネントの見通しを良くしています。

**Q9. パフォーマンス向上のために実装したことはありますか？`DataDivider.ts`や`SceneOptimizer.ts`の役割について説明してください。**

**A9.**
はい、Web上で大規模な3Dデータを扱うため、パフォーマンスは特に意識しました。主に3つのアプローチを実装しています。
1.  **Draco圧縮への対応**: `DataDivider.ts`内で、ファイルサイズが100MBを超える場合にDraco圧縮形式での読み込みを試みるようにしています。DracoはGoogleが開発した3Dデータの圧縮ライブラリで、モデルのファイルサイズを大幅に削減できます。`DracoCompression.Configuration`にデコーダーのパスを設定し、`SceneLoader`で読み込んでいます。
2.  **LOD（Level of Detail）の生成**: 同じく`DataDivider.ts`内で、読み込んだモデルを元に、高品質な`highModel`と、頂点数を削減した低品質な`lowModel`を動的に生成しています。そして`highModel.addLODLevel`メソッドを使い、カメラからの距離に応じて自動的にモデルの品質が切り替わるように設定し、描画負荷を軽減しています。
3.  **シーン全体の最適化**: `SceneOptimizer.ts`では、Babylon.jsが提供する`SceneOptimizer`機能を利用しています。これにより、目標フレームレート（60fps）を維持するために、テクスチャ解像度の動的な縮小や、シャドウ、パーティクルなどのエフェクトの品質を自動的に調整する設定を入れています。

**Q10. `husky`と`lint-staged`を導入していますが、これらはどのような目的で使っていますか？**

**A10.**
これらは、コードの品質をチーム開発（今回は個人開発ですが）で一貫して保つためのツールです。
-   **Husky**: Gitのコミットやプッシュといった特定のアクションの直前に、任意のスクリプトを自動実行させるためのツールです。
-   **lint-staged**: Gitのステージングエリアにあるファイル（コミット対象のファイル）に対してのみ、Linterやフォーマッタを実行するツールです。

このプロジェクトでは、`.husky/pre-commit`スクリプトで`yarn lint-staged`を実行するように設定しています。これにより、開発者が`git commit`を実行すると、コミット対象のファイル（`.lintstagedrc.js`で`pages/*.{js,jsx,ts,tsx}`と指定）に対して自動的に`prettier --write`が実行され、コードが整形されます。
これによって、フォーマットがバラバラなコードがリポジトリに混入することを防ぎ、コードレビューの負担を減らし、プロジェクト全体のコードの一貫性を保つことができます。

---

## 難易度：上級 (アーキテクチャの深い理解やトレードオフを問う質問)

このレベルでは、単一の正解がない問題に対し、技術的なトレードオフを理解した上で、自分の考えを述べることが求められます。

**Q11. `BabylonEditor.tsx`が500行近くと非常に大きいですが、これをリファクタリングするとしたら、どのように改善しますか？**

**A11.**
ご指摘の通り、`BabylonEditor.tsx`はエンジンとシーンの初期化、イベントリスナーの設定、アセット読み込みの副作用、UIのレンダリングなど多くの責務を担っており、肥大化しています。リファクタリングするならば、関心事の分離を徹底します。
1.  **Babylon.jsのセットアップロジックの分離**: `useEffect`内に記述されているエンジンとシーンの初期化、リサイズ処理、ギズモマネージャーのセットアップといったロジックを、`useBabylonScene`のようなカスタムフックに切り出します。このフックは`engine`と`scene`のインスタンスを返し、コンポーネントはそれを利用するだけにします。
2.  **アセット読み込みロジックの分離**: 現在`useAssetLoad`フックと`useEffect`の組み合わせで行っているアセット読み込み処理を、より責務が明確な`AssetLoader`のようなクラスまたはフックに完全に分離します。このクラスは`scene`を引数に取り、`load(url, type)`のようなメソッドを持つようにします。UIからのイベントはこのクラスのメソッドを呼び出すだけです。
3.  **UIコンポーネントの分割**: `FloatingControlPanel`内に記述されている`Inspector`や`LOD切り替えボタン`などを、それぞれ意味のある単位でコンポーネントとしてさらに細かく分割し、`BabylonEditor.tsx`からはそれらのコンポーネントを呼び出すだけにします。
これらの改善により、`BabylonEditor.tsx`は、各フックやコンポーネントを組み合わせてページを構成する責務に集中でき、可読性と保守性が向上すると考えます。

**Q12. 現状のファイルアップロード処理は、一度Next.jsサーバーを経由していますが、大規模な3Dファイルを扱う上でのボトルネックになり得ます。クライアントから直接クラウドストレージ（S3など）にアップロードする構成にするには、どのような設計を考えますか？**

**A12.**
はい、現状の`/api/uploads`はあくまで簡易的な実装であり、プロダクションレベルではサーバーの負荷や転送効率が問題になることを認識しています。クライアントから直接アップロードする構成としては、「署名付きURL（Presigned URL）」を利用する方式を考えます。
具体的なフローは以下のようになります。
1.  クライアント（ブラウザ）が、アップロードしたいファイル名やMIMEタイプといった情報を、Next.jsのAPIルート（例: `/api/generate-upload-url`）に送信します。
2.  APIルートは、AWS SDKなどを用いて、そのファイル専用の一時的なアップロード許可を持つ「署名付きURL」をS3から発行してもらい、そのURLをクライアントに返します。
3.  クライアントは、受け取った署名付きURLに対して、`PUT`リクエストでファイル本体を直接アップロードします。この通信はNext.jsサーバーを経由せず、ブラウザとS3の間で直接行われます。
4.  アップロード完了後、クライアントはNext.jsサーバーに完了通知を送り、サーバー側で「ファイルURLをデータベースに保存する」などの後続処理を行います。
この構成により、Next.jsサーバーは重いファイルの送受信から解放され、スケーラビリティが大幅に向上します。認証情報（AWSの秘密鍵など）をクライアントに渡す必要がなく、安全に直接アップロードを実現できるのが利点です。

**Q13. PWA（Progressive Web App）に対応していますが、このアプリにおいてPWA化はどのようなメリットをもたらしますか？また、Service Workerのキャッシュ戦略（`next.config.cjs`）で工夫した点はありますか？**

**A13.**
このアプリをPWA化することには、主に2つのメリットがあると考えています。
1.  **オフライン利用と高速起動**: Service Workerによるキャッシュを活用することで、一度アクセスすれば、オフライン環境でもアプリの基本的なUIを立ち上げることが可能になります。また、2回目以降のアクセスではキャッシュからリソースを読み込むため、起動が高速になります。3Dエディタのようなアプリケーションでは、エンジンやライブラリの読み込みに時間がかかるため、この恩恵は大きいと考えています。
2.  **ネイティブアプリのような体験**: ユーザーはアプリをホーム画面に追加でき、アイコンから直接フルスクリーンで起動できます。これにより、ブラウザのUIに邪魔されず、より没入感のあるエディタ体験を提供できます。

キャッシュ戦略については、`next-pwa`の設定でリソースの種類ごとに最適な戦略を選択するよう工夫しました。
-   **画像 (`.png`, `.jpg`など)**: `CacheFirst`戦略を採用しました。一度ダウンロードした画像は積極的にキャッシュから利用し、表示を高速化します。30日間キャッシュを保持するように設定しています。
-   **静的リソース (`.js`, `.css`)**: `StaleWhileRevalidate`戦略にしました。まずキャッシュから素早く表示しつつ、バックグラウンドで新しいバージョンがないか確認し、あれば次回の表示のために更新します。これにより、表示速度と更新の即時性のバランスを取っています。
-   **APIリクエストなどその他**: `NetworkFirst`戦略を基本とし、まずはネットワークからの最新データを試し、失敗した場合（オフライン時など）にキャッシュを利用するようにしています。

**Q14. 複数人でのリアルタイム共同編集機能を実装するとしたら、どのような技術やアーキテクチャを検討しますか？**

**A14.**
リアルタイム共同編集は非常に挑戦的な機能ですが、実装するとしたらWebSocketをベースにしたアーキテクチャを検討します。状態の同期には、Y.jsやAutomergeといったCRDTs（Conflict-free Replicated Data Types）ライブラリの採用が有力です。
アーキテクチャの概要は以下のようになります。
1.  **バックエンド**: WebSocketサーバーを立てます。Node.js環境で`ws`ライブラリや、より高機能な`Socket.IO`などを使います。このサーバーは、各クライアントからの操作情報を受け取り、同じセッション（ルーム）に参加している他のクライアントにブロードキャストする役割を担います。
2.  **状態管理**: 各クライアント（ブラウザ）とサーバーは、Y.jsのドキュメント（Y.Doc）を共有します。シーン内のオブジェクトの位置、回転、スケール、マテリアルの変更といった全ての状態をこのY.Docで管理します。
3.  **通信フロー**:
    -   あるクライアントがギズモでオブジェクトを動かすと、その操作（例: `object Aのpositionを(x, y, z)に変更`）は、まずローカルのY.jsドキュメントに適用されます。
    -   Y.jsは、この変更差分を非常にコンパクトなバイナリデータとして生成します。この差分データをWebSocket経由でサーバーに送信します。
    -   サーバーは受け取った差分データを、同じルームにいる他の全クライアントにブロードキャストします。
    -   他のクライアントは、差分データを受け取ると自身のY.jsドキュメントにマージします。CRDTsの特性により、どのような順序で差分が届いても、最終的に全クライアントのデータは同じ状態に収束します。
4.  **Babylon.jsへの反映**: 各クライアントは、自身のY.jsドキュメントの変更を監視し、変更があった箇所に対応するBabylon.jsのオブジェクトのプロパティを更新して、シーンに反映させます。
この構成により、サーバーは複雑な状態のマージロジックを持つ必要がなくなり、単純なメッセージの中継役としてスケールしやすくなります。

**Q15. 開発中に直面した最も大きな技術的課題は何でしたか？それをどのように乗り越えましたか？**

**A15.**
最も大きな課題は、Babylon.jsの`SceneLoader`が返すPromiseベースの非同期処理と、Reactのライフサイクルをうまく組み合わせることでした。
特に、ユーザーがファイルをインポートした際に、モデルの読み込み完了を待ってからでないと実行できない処理（例: ギズモをアタッチする、インスペクターを更新する）の制御に苦労しました。当初、`useEffect`内で`SceneLoader.AppendAsync`を呼び出していましたが、読み込み完了を待たずに`useEffect`のクリーンアップ関数が呼ばれてしまうなど、タイミングの問題が多発しました。
この解決策として、
1.  **責務の明確化**: `useAssetLoad`フックはあくまでファイル選択とURL生成に責務を絞り、実際の読み込み処理は`BabylonEditor`コンポーネントの`useEffect`内で行うようにしました。
2.  **async/awaitの徹底**: `useEffect`のコールバック関数自体は`async`にできませんが、その内部で`async`な即時実行関数を定義し、その中で`await SceneLoader.AppendAsync(...)`を呼び出す形にしました。これにより、Promiseが解決されるまで、つまりモデルの読み込みが完了するまで、後続の処理を確実に待機させることができました。
3.  **ローディングステートの活用**: `isLoading`や`loadingProgress`といった状態をRecoilやuseStateで管理し、`useAssetLoad`フックから`SceneLoader`の進捗コールバックを通じて状態を更新するようにしました。これにより、UI上でもユーザーに明確なフィードバックを返すことができるようになり、非同期処理の進行状況が分かりやすくなりました。
この経験を通じて、Reactコンポーネント内で複雑な非同期APIを扱う際の、状態管理と副作用の適切な分離方法について深く学ぶことができました。
